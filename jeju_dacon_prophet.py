# -*- coding: utf-8 -*-
"""jeju_dacon_prophet

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r0OL82in0HJUdJN_Ont0KYpRmkTxkMfP
"""

import pandas as pd
import numpy as np
from prophet import Prophet
from sklearn.model_selection import ParameterSampler
from sklearn.metrics import mean_squared_error

train = pd.read_csv('/content/drive/MyDrive/kaggle/open/train.csv')
test = pd.read_csv('/content/drive/MyDrive/kaggle/open/test.csv')

"""#Prophet"""

# Assuming train is your training data
prophet_data = train.rename(columns={'timestamp': 'ds', 'price(원/kg)': 'y'})
prophet_data = prophet_data[['ID', 'ds', 'y']]
prophet_data['ID'] = prophet_data['ID'].str.replace(r'_\d{8}$', '', regex=True)

# Function for hyperparameter tuning
def ph_tune(df):
    param_grid = {
        'growth': ['linear', 'logistic'],
        'seasonality_mode': ['additive', 'multiplicative'],
        'yearly_seasonality': [5, 10, 15],  # You can try different values
        'weekly_seasonality': [3, 5, 7],  # You can try different values
        'daily_seasonality': [False, True],
        'changepoint_prior_scale': [0.01, 0.05, 0.1],  # Experiment with different values
    }

    pred_list = []
    for code in df['ID'].unique():
        d = df[df['ID'] == code].reset_index().drop(['ID'], axis=1).sort_values('ds')

        # Add a 'cap' column with the maximum value in 'y' as the capacity
        d['cap'] = d['y'].max()

        # Split data into training and validation sets
        train_size = int(len(d) * 0.8)
        train, valid = d.iloc[:train_size], d.iloc[train_size:]

        # Use random search for hyperparameter tuning
        param_combinations = ParameterSampler(param_distributions=param_grid, n_iter=10, random_state=42)
        best_params = None
        best_score = float('inf')  # Adjust based on your metric

        for params in param_combinations:
            model = Prophet(**params)
            model.fit(train)

            # Make predictions on the validation set
            forecast = model.predict(valid)

            # Evaluate the model using mean squared error (you can use a different metric)
            score = mean_squared_error(valid['y'], forecast['yhat'])

            if score < best_score:
                best_score = score
                best_params = params

        # Train the model with the best parameters on the full training set
        model = Prophet(**best_params)
        model.fit(d)

        # Make predictions
        future = pd.DataFrame()
        future['ds'] = pd.date_range(start='2023-03-04', periods=28, freq='D')
        future['cap'] = d['cap'].max()  # Set cap for future predictions
        forecast = model.predict(future)

        pred_y = forecast['yhat'].values
        pred_code = [str(code)] * len(pred_y)
        for y_val, id_val in zip(pred_y, pred_code):
            pred_list.append({'ID': id_val, 'y': y_val})

    pred = pd.DataFrame(pred_list)
    return pred

# Call the function for hyperparameter tuning
pred = ph_tune(prophet_data)

# Rest of your code remains unchanged
submission_df = pd.read_csv('/content/drive/MyDrive/kaggle/open/sample_submission.csv')
submission_df['answer'] = pred['y']
submission_df.to_csv('prophet_tuned.csv', index=False)

"""#prophet optuna"""

prophet_data = train.rename(columns={'timestamp': 'ds', 'price(원/kg)': 'y'})
prophet_data = prophet_data[['ID', 'ds', 'y']]
prophet_data['ID'] = prophet_data['ID'].str.replace(r'_\d{8}$', '', regex=True)

# Optuna용 목적 함수 정의
def objective(trial):
    pred_list = []
    for code in prophet_data['ID'].unique():
        d = prophet_data[prophet_data['ID'] == code].reset_index().drop(['ID'], axis=1).sort_values('ds')

        model = Prophet(
            growth='linear',
            seasonality_mode='additive',
            yearly_seasonality=trial.suggest_int('yearly_seasonality', 1, 20),
            weekly_seasonality=trial.suggest_int('weekly_seasonality', 1, 10),
            daily_seasonality=trial.suggest_categorical('daily_seasonality', [True, False]),
            holidays=None,
            changepoint_prior_scale=trial.suggest_float('changepoint_prior_scale', 0.001, 0.5),
        )

        model.fit(d)

        future = pd.DataFrame()
        future['ds'] = pd.date_range(start='2023-03-04', periods=28, freq='D')
        forecast = model.predict(future)

        pred_y = forecast['yhat'].values
        pred_code = [str(code)] * len(pred_y)

        for y_val, id_val in zip(pred_y, pred_code):
            pred_list.append({'ID': id_val, 'y': y_val})

    pred = pd.DataFrame(pred_list)
    target = prophet_data[['ID', 'y']]

    return np.sqrt(((pred['y'] - target['y'])**2).mean())  # 작업에 따라 목적 함수를 조정해야 합니다.

# Optuna 최적화
study = optuna.create_study(direction='minimize')
study.optimize(objective, n_trials=50)  # 시도 횟수를 조정할 수 있습니다.

# 최적 파라미터 얻기
best_params = study.best_params
print("Best Parameters:", best_params)

# 최적 파라미터를 사용하여 최종 모델 학습
final_model = Prophet(
    growth='linear',
    seasonality_mode='additive',
    yearly_seasonality=best_params['yearly_seasonality'],
    weekly_seasonality=best_params['weekly_seasonality'],
    daily_seasonality=best_params['daily_seasonality'],
    holidays=None,
    changepoint_prior_scale=best_params['changepoint_prior_scale'],
)

final_model.fit(prophet_data)

# 최종 모델을 사용하여 예측 생성
final_predictions = ph_train(prophet_data)
submission_df = pd.read_csv('/content/drive/MyDrive/kaggle/open/sample_submission.csv')
submission_df['answer'] = final_predictions['y']
submission_df.to_csv('prophet_optuna.csv',index=False)